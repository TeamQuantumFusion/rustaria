//! This is the third time i remake our entire pass system. This time its sick.
pub mod brush;
pub mod context;
pub mod pass;
pub mod sampler;

use pass::Pass;
use rayon::prelude::{IntoParallelIterator, IntoParallelRefIterator, ParallelIterator};
use std::ops::Range;

use crate::pipeline::context::Context;
use crate::table_map::{TableMapMutSlice, TableMapSlice};
use crate::{Climate, Generator, TableMap, Zone, BATCH_SIZE};

#[must_use = "You must call complete()."]
pub struct Pipeline<'a, T, V>
where
	V: Send + Sync,
	T: Clone + Default + Send + Sync,
{
	context: Context<'a, T>,
	passes: Vec<(V, Pass)>,
}

impl<'a, T, V> Pipeline<'a, T, V>
where
	V: Send + Sync,
	T: Clone + Default + Send + Sync,
{
	pub fn map<NV: Send + Sync>(
		self,
		func: impl Fn(&Pass, Context<'a, T>, V) -> NV + Sync + Send,
	) -> Pipeline<'a, T, NV> {
		Pipeline {
			passes: self
				.passes
				.into_par_iter()
				.map(|(value, pass)| (func(&pass, self.context.clone(), value), pass))
				.collect(),
			context: self.context,
		}
	}

	pub fn map_with_map<O: Sync, NV: Send + Sync>(
		self,
		map: &'a TableMap<O>,
		func: impl Fn(&Pass, Context<'a, T>, V, TableMapSlice<'a, O>) -> NV + Sync + Send,
	) -> Pipeline<'a, T, NV> {
		Pipeline {
			passes: self
				.passes
				.into_par_iter()
				.map(|(value, pass)| {
					let slice = map.slice(pass.x_range.clone(), pass.y_range.clone());
					(func(&pass, self.context.clone(), value, slice), pass)
				})
				.collect(),
			context: self.context,
		}
	}

	// x, y, current_value, pass, your_value
	pub fn apply<O: Sync>(
		self,
		map: &'a mut TableMap<O>,
		func: impl Fn(u32, u32, &Pass, Context<'a, T>, &V, &mut TableMapMutSlice<'a, O>) + Sync,
	) -> Pipeline<'a, T, V> {
		let map = &*map;
		self.passes.par_iter().for_each(|(value, pass)| {
			// This is actually safe, The passes are private and are generated by us.
			// The range ensures only the intended pass area can be changed so data races are not a thing
			// because they are modifying distinct areas of the table-map.
			let table = unsafe { &mut *(map as *const TableMap<O> as *mut TableMap<O>) };
			let mut slice = table.slice_mut(pass.x_range.clone(), pass.y_range.clone());

			for y in pass.y_range.clone() {
				for x in pass.x_range.clone() {
					func(x, y, pass, self.context.clone(), value, &mut slice);
				}
			}
		});

		self
	}

	pub fn complete(self) {}
}

impl<'a, T> Pipeline<'a, T, ()>
where
	T: Clone + Default + Send + Sync,
{
	pub fn for_zone(gen: &'a Generator<T>, zone: &Zone) -> Pipeline<'a, T, ()> {
		Self::new(gen, 0..gen.width, zone.world_range.clone(), BATCH_SIZE)
	}

	pub fn for_climate(
		gen: &'a Generator<T>,
		zone: &Zone,
		climate: &Climate,
		climate_x_range: &Range<u32>,
	) -> Pipeline<'a, T, ()> {
		let y_offset = zone.world_range.start;
		let height = ((zone.world_range.end - y_offset) as f32 * climate.depth) as u32;

		Self::new(
			gen,
			climate_x_range.clone(),
			y_offset..(y_offset + height),
			BATCH_SIZE,
		)
	}

	pub fn new(
		gen: &'a Generator<T>,
		x_range: Range<u32>,
		y_range: Range<u32>,
		batch_size: usize,
	) -> Pipeline<'a, T, ()> {
		let width = x_range.end - x_range.start;
		let height = y_range.end - y_range.start;

		let pass_width = (width as f32 / batch_size as f32).ceil() as u32;
		let pass_height = (height as f32 / batch_size as f32).ceil() as u32;
		let mut passes = Vec::new();
		for y in 0..pass_height {
			for x in 0..pass_width {
				let batch_size = batch_size as u32;
				let x_pos = x * batch_size;
				let y_pos = y * batch_size;

				let width = (x_pos + batch_size).min(width) - x_pos;
				let height = (y_pos + batch_size).min(height) - y_pos;
				let x = x_range.start + x_pos;
				let y = y_range.start + y_pos;

				passes.push((
					(),
					Pass {
						x_range: x..(x + width),
						y_range: y..(y + height),
					},
				))
			}
		}

		Pipeline {
			context: Context {
				generator: gen,
				x_range,
				y_range,
			},
			passes,
		}
	}
}
